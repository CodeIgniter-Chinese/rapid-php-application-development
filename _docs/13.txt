快捷的 CRUD 及其配合使用



　　编写任何一个动态网页时，最基本的，也是最令人厌烦的部分是 CRUD。你有一个或多个数据表时，你需要去对它们每一个实体进行建立、读取、更新与删除。后来，你将对数据处理会变得灵活，但在此之前也有一些界面友好的方式来处理它，并保留下来，但对你的网站是不能用的。

　　不过，这牵涉到写各种各样的 CRUD 方法，虽然在理念上相当容易，但这些是相当复杂且费时的工作。所以对于我们的网站，我写了一个通用的 CRUD 模型，使用 CI 的类及辅助函数，使之更加容易。在这一章中，你会看到这个模型如何工作，如何将它集成到我们的应用程序中来。

　　CRUD 模型不只是 CRUD。它验证用户输入的数据，并用多种方式检查它。如：当你在特定行做“delete”操作时，或者通过返回进入到表单并且在你的浏览器中重新加载它，你不小心重复“create”操作时。

　　最后，CRUD 模型包含了它自己的自检框架，因此你能够把它作为你的架构或适应你的代码，进行开发测试。

　　CRUD 除此之外，还能做更全面，更优秀的代码（参见第 15 章）。然而，我们所要做的是对我们以前所学的课程进行一个好的总结与提高。

　　此章对模型所要展示的代码如下：





    * 设计原理。

    * 一个标准的控制器与模型配合使用。

    * 数据库表必须是有条理的。

    * 模型本身: 保存数据库信息的数组、分离函数。

    * 自检函数。









CRUD 模型: 设计原理



　　在这个 CRUD 模型背后的想法是它能被任何表的任何控制器所调用。对于数据表的数据，在一个数组中，如何从过去显示的数据去更新它，所有都是标准：控制器恰好识别它自己（并且在表中起作用）并且需要对每条记录给一个 ID 号。因此我们不得不写一些简单的控制器，连接到数据库去取数据，并展现它到表单中去。

　　记得我们不能直接使用一个模型，因此每次我们不得不需要通过一个控制器不使用它。你可以放一些代码到控制器中，但你不得不复制它到其它新的控制器中去。有一种方法，只通过在模型中的一套 CRUD 代码，我们就能去更新，去维护了。代价是你必须去保持控制器与模型之间来去通畅，如何使代码更简洁，更多的困难在后面。

　　为了简单，我们使用在代码中没有定义的两个扩展函数：





    * failure(), 当报告有错误时，我们仍然想继续执行。

    * 被调用的模型显示－建立菜单与设置基准URL等。因而CRUD函数建立了一大堆数据，放在 $data 变量中，可以简单的调用：

      复制内容到剪贴板

      PHP 代码:



         1.

            $this->display->mainpage($data);





　　我想让 CRUD 模型能够自检，因此它包含了一个自检组件。如果我们愿意的话，可以在设计处理期间允许我们去调用它。(编写测试套件会让你发现很多错误，起初不经意的地方会出现错误让你很是意外，但是现在发现错误，总比以后你的客户访问网站发现错误要好。)

　　请以一个折衷的方法记住每一个模型。你要求它的越多，它要求你的也越多。例如，除非你的数据库表以某种特殊方式下，这个模型它不工作。它以完全的高级方式显示在表格中，但它不能灵活处理。它没有使用 Javascript 来更好的适应用户的习惯。它不能用它自己的规则来处理异常。在其它方面，如果你只想实现一系列标准事件（它是很通用的），它是很简单达到的。





标准的控制器格式



　　首先，对每一个数据表，你需要有一个标准的控制器。它是怎样让用户与你的数据表接口，如：新增记录，更新记录等。对于新增一个新的人员，用户将与人员数据表对接，因此需要一个不同的控制器：但它与其它的控制器大多是相同的。

　　下面是我们一个 Sites 数据表的控制器：

复制内容到剪贴板

PHP 代码:



   1.

      <?php

   2.

      class Sites extends Controller {

   3.

       

   4.

      /*the filename, class name, constructor function names and this

   5.

      variable are the only thing you need to change: to the name of the

   6.

      table/controller (First letter in upper case for the Class name and

   7.

      constructor function, lower case for the file and variable.lower

   8.

      case!)*/

   9.

          var $controller  = 'sites';

  10.

      /*constructor function*/

  11.

          function Sites()

  12.

          {

  13.

                parent::Controller();

  14.

                $this->load->model('crud');

  15.

          }

  16.

       

  17.

      /*function to update an entry (if an ID is sent) or to insert a new

  18.

      one. Also includes validation, courtesy of CI */

  19.

         function insert($id)

  20.

         {

  21.

                $this->crud->insert($this->controller, $id);

  22.

         }

  23.

       

  24.

      /*interim function to pass post data from an update or insert through

  25.

      to Crud model, which can't receive it directly*/

  26.

         function interim()

  27.

         {

  28.

                $this->crud->insert2($this->controller, $_POST);  

  29.

         }

  30.

       

  31.

      /*function to delete an entry, needs table name and id. If called

  32.

      directly, needs parameters passed to function; if not, from Post

  33.

      array*/

  34.

          function delete($idno=0, $state='no')

  35.

          {

  36.

                if(isset($_POST['id'])&& $_POST['id'] > 0)

  37.

                       {$idno = $_POST['id'];}

  38.

                if(isset($_POST['submit']))

  39.

                       {$state = $_POST['submit'];}Instant CRUD―or Putting it All Together

  40.

       

  41.

                $this->crud->delete($this->controller, $idno, $state);

  42.

          }

  43.

       

  44.

      /*function to show all entries for a table*/

  45.

         function showall()

  46.

         {

  47.

                $this->crud->showall($this->controller, $message);

  48.

         }

  49.

       

  50.

      /*function to show all data in a table, but doesn't allow any

  51.

      alterations*/

  52.

         function read()

  53.

         {

  54.

                $this->crud->read($this->controller);

  55.

         }

  56.

       

  57.

      /*function to set off the test suite on the 'crud' model. This

  58.

      function need only appear in one controller, as these tests are made

  59.

      on a temporary test table so that your real data is not affected*/

  60.

         function test()

  61.

         {

  62.

         $this->crud->test();  

  63.

         }

  64.

      }

  65.

      ?>



　　你领会之后，你会发现它是优美苗条并且十分通用的。如果你想让 people 控制器去代替 Sites 控制器--换句话说，允许你在 people 表中去建立，读取，更新或删除记录，等等，你需要做如下事情：





    * 更改 Sites 为 People (首字母大写!)。

    * 更改 $controller 变量 sites 为 people (小写)。

    * 更改构造函数名Sites 为 People (首字母大写)。

    * 保存新的控制器为：system/application/controllers/people.php.





　　控制器名必须严格的与数据表名一样，如对于 people 表，它必须是 people。在类定义行与构造函数中，名字的首字母必须是大写，但是其他地方不一定要这样。





数据库表



　　对于你的数据表有三个简单的规则：





    * 最主要是第个表有 ID 字段为主键并且为自增字段 (这是一个标准的 MySQL 字段类型。新增记录时，自动建立一个新的不重复的数字)。

    * 如果你想使用它在一个动态的下拉列表，你有一个 NAME 字段。

    * 你也必须有一个 SUBMIT 字段来存储状态，殊如等等。





　　除此之外，你可拥有任何你想要的字段，并随意对其命名，其他所有都由 CRUD 模块处理，适用于设计针对与这些行一起配合成对的任何控制器/数据表。





模型的心脏：数组



　　准备工作完成后。让我们开始创建 CRUD 模型吧。

　　首先你需要定义 CRUD 模型与一个构造函数。标准写法如下：

复制内容到剪贴板

PHP 代码:



   1.

      <?php

   2.

      class Crud extends Model {

   3.

       

   4.

      /*create the array to pass to the views*/

   5.

          var $data = array();

   6.

          var $form = array();

   7.

          var $controller;

   8.

       

   9.

       

  10.

          function Crud()

  11.

          {

  12.

              // Call the Model constructor

  13.

              parent::Model();

  14.

              $this->load->helper('form');

  15.

              $this->load->helper('url');

  16.

              $this->load->library('errors');

  17.

              $this->load->library('validation');

  18.

              $this->load->database();

  19.

              $this->load->model('display');



　　保存它到 system/application/models/crud.php。

　　继续钻研，但你仅需要做一次下面的事。你要写一个多维数组（我刚开始的时候从一本书上学的PHPDD它是非常好的DD上面说“多维数组不会经常遇到，因此我们以后都没有必要深入的学习它”。看来现在开始就要用它了）。

　　我们数组的一维是数据表列表（sites,pepple,等）。二维是每个表的字段列表。对于 sites 表，就是 id, name, url 等。三维是描述每个字段与提供将在插入/更新表单中处理控制的一组变量。如下：





    * 在输入框显示你想希望被用户看的文本: 这个字段是如何向人们描述的.(所以它的第一个字段是网站 ID 而不仅仅是 ID). 这个会让你的表单更加用户友好。

    * 你可以在你的插入/更新表单上显示表单类型的字段: 这可以是一个输入框、一个文本域或者一个下拉框。(CRUD 模型定制了一些设置但不是全部。)

    * 当用户填写表单的时候，你可以加入 CI 的验证规则。这个可以留空。

    * 如果你希望动态下拉框显示这个字段, 它的表名将会显示出来.看下面的这个解释,它也同样可以留空。





　　我们已经声明了类里面的一个变量 $form 为数组，所以以后任何时候，我们必须这样用它 $this->form。它被定义在构造函数里, 它直接跟随前面的代码。

复制内容到剪贴板

PHP 代码:



   1.

                $this->form =

   2.

                array

   3.

                ('sites' => array

   4.

                (

   5.

                'id'        => array('ID number of this site',  

   6.

                               'readonly', 'numeric'),

   7.

                'name'      => array('Name of site', 'textarea',  

   8.

                               'alpha_numeric'),

   9.

                'url'       => array('Qualified URL,  

  10.

                               eg http://www.example.com', 'input', ''),

  11.

                'un'        => array('username to log in to site',  

  12.

                               'input', 'numeric|xss_clean'),

  13.

                'pw'        => array('password for site', 'input',  

  14.

                               'xss_clean'),

  15.

               'client1'     => array('Main client',  

  16.

                                'dropdown', '', 'people' ),

  17.

               'client2'     => array('Second client', 'dropdown',  

  18.

                                '', 'people'),

  19.

               'admin1'      => array('First admin', 'dropdown',  

  20.

                                '', 'people'),

  21.

               'admin2'      => array( 'Second Admin', 'dropdown',  

  22.

                                '', 'people'),

  23.

               'domainid'    => array('Domain name', 'dropdown',  

  24.

                                'numeric', 'domains'),

  25.

               'hostid'      => array( 'Host', 'dropdown',

  26.

                                'numeric', 'hosts'),

  27.

               'submit'      => array( 'Enter details', 'submit', 'mumeric')

  28.

                ),

  29.

               'domains' => array

  30.

                (

  31.

                'id'         => array('ID number of this domain',  

  32.

                                'hidden', 'numeric'),

  33.

      //etc etc etc!!



　　你会发现 $from 数组里每一个表(这里指站点和域名，虽然由于空间的原因我只开通了后者)都有一个二级数组，每个二级数组都包含了他们自有的三级数组，每一个字段（“id”、“name”等等）对应一个。每个三级数组都是依次排列在数组中，包含了三个或者四个在前面描述的值。

　　你并不能很容易的理解这种数组，但是从概念上看很简单。

　　为完成我们应用程序中的表的设置，创建该数组约需 120 行。但是，你只需要去做一次！这是你的模型的心脏。用括号'}'关闭这个构造函数，并继续创建 CRUD 模型的其他方法。

　　如果你需要改变你的数据库表（例如添加一个新的字段），或者你要改变你的验证规则，那么你只需要改变数组里的数值。他们将会自动更改：举例来说，当您下次尝试增加新的条目时，你应该看到在表上反映的变化。





CRUD 模型



　　以下各个方法组成了 CRUD 模型：





Showall 方法



　　这是一个用户最常用的方法。它可以作为一个切入点，对输入所有其他的操作，添加，更新，或删除。它显示你表里已有内容。网站表上的一些测试数据，它看起来是这样的：

1.gif (10.74 KB)

2008-3-5 18:26



　　如同你看到的，在这个页面中你可以更新或删除整个网站。你可以添加新的内容，或者从表中读取所有数据。

　　顺便说一句，请大家不要忘记，该模型并不包括任何安全规定。在一个真实的网站中，你也许要微调用户的选项-例如，允许更新而不能删除。你要确保黑客无法通过输入 URL(例如:www.example.com/index.php/sites/delete/18) 访问 CRUD 模型的功能。CI 的基于 URL 的结构使得它比较容易推断出系统如何访问这些命令，所以你可能希望在 CRUD 模型激活以前，确保用户已登录到网站中。

　　回到 CRUD 机制。记住，用户不能直接调用模型。每一个操作（删除，更新等）都是通过控制器来调用的。控制器用下面这行代码调用 showall 方法：

复制内容到剪贴板

PHP 代码:



   1.

                $this->crud->showall($this->controller);



　　换句话说，就是用 showall 方法取代网站的 $this->controller，并传递一个参数到 CRUD 方法中，就是要告诉它，它在取代哪个控制器的功能。

　　我们现在来看看 showall 方法。我们已经把第一个参数传递给它了。我们把 $message 留到后面。集中看标为高亮的行。

复制内容到剪贴板

PHP 代码:



   1.

      /*this function lists all the entries in a database table on one

   2.

      page. Note that every db table must have an 'id' field and a 'name'

   3.

      field to display!

   4.

      This page is a jumping-off point for the other functions - ie to

   5.

      create, read, update or delete an entry.

   6.

      When you've done any of these, you are returned to this page. It has a

   7.

      'message' parameter, so you can return with a message - either success

   8.

      or failure.*/

   9.

       

  10.

      function showall($controller='', $message = '', $test ='no')

  11.

      {

  12.

                $result = '';

  13.

                $mysess = $this->session->userdata('session_id');

  14.

                $mystat = $this->session->userdata('status');

  15.

                if(!$this->db->table_exists($controller))

  16.

                       {

  17.

                        $place =  __FILE__.__LINE__;

  18.

                        $outcome = "exception:$place:looking for table

  19.

      $controller: it doesn't exist'";

  20.

      /*test block: what if there is no controller by that name?*/

  21.

                        if($test =='yes')

  22.

                             {  

  23.

                              return $outcome;

  24.

                             }

  25.

                       else{

  26.

                         $this->failure($outcome, 'sites');

  27.

                             }

  28.

                       }

  29.

      /*end test block*/

  30.

                $this->db->select('id, name');

  31.

                $query = $this->db->get($controller);

  32.

                if ($query->num_rows() > 0)

  33.

                      {

  34.

                      $result .= "<table class='table'>";Instant CRUD―or Putting it All Together

  35.

       

  36.

                      $result .= "<tr><td colspan='3'><h3>$controller</h3></

  37.

                                                                td></tr>";  

  38.

                      $result .= "<tr><td colspan='3' class='message'>

  39.

                                                        $message</td></tr>";

  40.

                      $result .= "<tr><td colspan='3'>";

  41.

                      $result .= anchor("$controller/insert/0", 'New entry');

  42.

                      $result .= "</td></tr>";

  43.

                      $result      .= "<tr><td colspan='3'>";

  44.

                      $result .= anchor("$controller/read",  

  45.

                                          'Show all entries in the table');

  46.

                      $result .= "</td></tr>";

  47.

                       foreach ($query->result() as $row)

  48.

                              {

  49.

                              $result .= "<tr><td>";

  50.

                             $result .= $row->id;

  51.

                             $result .= " ";

  52.

                             $result .= $row->name;

  53.

                             $result .= "</td><td>";

  54.

                             $result .= anchor("$controller/insert/

  55.

                                             $row->id",'Update this entry');

  56.

                             $result .= "</td><td>";

  57.

                             $result .= anchor("$controller/delete/

  58.

                                                        $row->id",'Delete');

  59.

                             $result .= "</td></tr>";

  60.

                             }

  61.

       

  62.

       

  63.

                      $result .= "</table>";

  64.

       

  65.

       

  66.

                      $data['text'] = $result;

  67.

                      $this->display->mainpage($data, $this->status);

  68.

                      }  

  69.

                else

  70.

                      {$place =  __FILE__.__LINE__;

  71.

                      $outcome = "exception: $place:  

  72.

                                         no results from table $controller";

  73.

      /*test block: were there results from this table/ controller?*/

  74.

                       if($test == 'yes')

  75.

                             {$place =  __FILE__.__LINE__;  

  76.

                             return $outcome;

  77.

                             }

  78.

      /*end test block*/

  79.

                       else{

  80.

                            $message = "No data in the $controller table";

  81.

      /*note: this specific exception must return to another controller

  82.

      which you know does contain data…… otherwise, it causes an infinite

  83.

      loop! */

  84.

                             $this->failure($message, 'sites');

  85.

                             }

  86.

                       }  

  87.

      }



　　它列出了一张表，展示了关于每个条目的一些数据（ID 和名称）。你也可以选择更新或删除功能，以更新或删除该条目：这是利用 CI 的 anchor 函数创建超链接，并链接到适当控制器中的适当方法。

　　这也有一行代码，为你提供了创造一个新站点的机会，再通过超链接连接到控制器的 insert 方法。（注：我将添加新的条目和更新旧的条目都称为 insert 方法，这是因为，模型假设如果插入的是已存在的 ID 号码，它将更新相应的条目，如果没有对应的 ID，它会创建一个新的条目）。

　　很多代码都采用了异常处理：例如该表不存在，例如查询没有返回信息。异常会传递到 failure 方法中。此外，还有两个测试模块，允许我运行自我测试。

　　此外，还有一行代码，允许你读取（但不修改）表中的所有数据。让我们先看看最简单的 read 方法。





读取数据



　　我用 CI 的 HTML 表格类(见第 10 章)和 Active Record 类(见第 4 章)简单演示了这个功能片段。我想用数据库中的所有数据把页面格式化成 HTML 表格。它不允许有任何的更改：这就是用于'读取'的页面。

　　首先，控制器中必须有一个方法来调用模型，并告诉该模型要显示哪个控制器/表。read() 是标准控制器中的方法。

　　在 CRUD 模型中调用下列方法:

复制内容到剪贴板

PHP 代码:



   1.

      /*queries the table to show all data, and formats it as an HTML

   2.

      table.*/

   3.

      function read($controller)

   4.

      {

   5.

                $this->load->library('table');

   6.

                $tmpl = array (

   7.

                          'table_open'          => '<table border="1"

   8.

      cellpadding="4" cellspacing="0" width="100%">',

   9.

                          'row_alt_start'       => '<tr bgcolor="grey">',

  10.

                    );

  11.

       

  12.

                $this->table->set_template($tmpl);

  13.

                $this->load->database();

  14.

                $this->load->library('table');

  15.

                $query = $this->db->get($controller);Instant CRUD―or Putting it All Together

  16.

       

  17.

                $result =  $this->table->generate($query);

  18.

                $data['text'] = $result;

  19.

                $this->display->mainpage($data);

  20.

      }



　　高亮显示的两行代码处理所有的数据库查询工作，并格式化结果。

　　我用 display 类中的 mainpage 方法来格式化该页：这里的 read 方法组织数据并把它变成数组的一部分。

　　其结果是由 test 文件的所有数据组成的页面：

2.gif (5.27 KB)

2008-3-5 18:26



　　让我们再次提醒自己控制行为是如何在控制器、CRUD 模型和程序其他部分之间传递的。

3.jpg (13.64 KB)

2008-3-5 18:26







Delete 和 Trydelete 方法



　　删除是不可逆的操作! 基于这个原因，我们的 delete 方法将确认两件事：





    * 在 “submit”字段中的状态变量已被设置为“yes”：如果不是，传递请求到 trydelete 方法中。即询问用户，她或他是否真的想删除。如果她或他确认，trydelete 方法设置状态变量为“yes”，并发送请求到 delete 方法，然后删除将被执行。

    * 执行删除查询以前，它会检查 ID 号是否已设置(否则可能删除所有内容)。然后，它使用 CI 的 Active Record 执行删除，并确定此行已从数据库表中删除。如果此行已删除，则返回到 showall 方法中。你会发现它传回两个参数--控制器名称和一个报告删除已成功执行的消息。(这是 showall 的第二个参数。如果设置它，则会在表格的顶部显示一个红框，以便让用户知道怎么回事。)





　　首先，这是 delete 方法。你会发现这个代码也因为“test block”代码行而变得复杂了很多。先忽略这些：只看高亮的代码。

复制内容到剪贴板

PHP 代码:



   1.

      /*DELETE FUNCTION: given table name and id number, deletes an entry*/

   2.

         function delete($controller, $idno, $state='no', $test='no')

   3.

                {

   4.

      /*first check that the 'yes' flag is set. If not, go through the

   5.

      trydelete function to give them a chance to change their minds*/

   6.

                if(!isset($state) || $state != 'yes')

   7.

                {

   8.

      /*test block: are 'yes' flags recognised?*/

   9.

                       if($test == 'yes')

  10.

                       {

  11.

                              $place =  __FILE__.__LINE__;  

  12.

                              $outcome = "exception at $place: sent state

  13.

      value $state to trydelete function ";

  14.

                              return $outcome;  

  15.

                        }

  16.

                       else  

  17.

      /*end test block*/

  18.

                         {$this->trydelete($controller, $idno, 'no');}

  19.

                       }

  20.

                else{

  21.

      /*'yes' flag is set, so now make sure there is an id number*/

  22.

                if(isset($idno) && $idno > 0 && is_int($idno))

  23.

      /*test block: with this id no, am I going to do a delete?*/

  24.

                       {

  25.

                       if($test == 'yes')

  26.

                       {

  27.

                             $place =  __FILE__.__LINE__;  

  28.

                             $outcome = "OK at $place:  

  29.

                                              doing delete on id of $idno ";Instant CRUD―or Putting it All Together

  30.

       

  31.

                             return $outcome;  

  32.

                             }

  33.

                       else{

  34.

      /*end test block*/

  35.

      /*if there is an id number, do the delete*/

  36.

                             $this->db->where('id', $idno);

  37.

                             $this->db->delete($controller);

  38.

                             $changes = $this->db->affected_rows();

  39.

                             }

  40.

       

  41.

                       if($changes != 1)

  42.

                       {

  43.

      /*test block: did I actually do a delete? */

  44.

                             $place =  __FILE__.__LINE__;

  45.

                             $outcome = "exception at $place: cdnt do delete

  46.

      op on $controller with id no of $idno";

  47.

                             if($test == 'yes')

  48.

                                            {return $outcome;}

  49.

                             else   

  50.

      /*end test block*/

  51.

      /*if there was no update, report it*/

  52.

                                           {$this->failure($outcome);}   

  53.

                          }

  54.

                       else{

  55.

      /*test block: I did do a delete*/

  56.

                             if($test == 'yes')

  57.

                                    {return 'OK';}

  58.

                             else{

  59.

      /*end test block: report the delete*/   

  60.

                              $this->showall($controller,  

  61.

                                               "Entry no. $idno deleted.");}

  62.

                             }

  63.

                       }

  64.

                else

  65.

      /*test block: report id number wasn't acceptable'*/

  66.

                       {

  67.

                       $place =  __FILE__.__LINE__;

  68.

                       $outcome = "exception at: $place : id no of $idno set

  69.

      for delete op in $controller, expecting integer";

  70.

                             if($test == 'yes')

  71.

                                    {return $outcome;}

  72.

                             else   

  73.

      /*endtest block: if I failed, report me*/

  74.

                                    {$this->failure($outcome);}   

  75.

                       }

  76.

                 }

  77.

         }



　　我答应过要解释一下 showall 方法的 $message 参数。你看它在这：如果这个功能执行成功，它将用一个合适的消息调用 showall，并返回该页：

复制内容到剪贴板

PHP 代码:



   1.

          $this->showall($controller, "Entry no. $idno deleted.");}



　　重要的不仅仅是操作的完成，还要让用户知道操作已完成。

　　现在，回到防止意外删除的话题。如果没有用 state=yes 参数调用 delete 方法，它将重新分配请求到 trydelete 方法中--“第二次机会”。实际上，只有 trydelete 方法会设置这个参数为 yes，所以，表单删除会一直提示你是否确认删除操作。

　　让我们看看 trydelete 方法。它创建一个简单的表单，看起来像这样：

4.gif (2.56 KB)

2008-3-5 18:26



　　单击“yes”重新调用 delete 方法。(注意：表单不能直接返回到 crud/delete，因为表单不能指向一个模型。它已经指向控制器中的 sites/delete 方法，该方法只是简单的将所有参数直接传递给模型中的 crud/delete 方法。)

　　这个微妙的改变是，如果用户确认删除，trydelete 表单将添加(作为一个隐藏域) submit=yes 参数，该参数将保存在 post 数组中，然后，返回到控制器的 delete 方法。控制器的 delete 方法从 post 数组中取出 submit=yes 参数，并把 state=yes 作为参数来调用 crud/delete 方法，然后 delete 方法转至下一个步骤。

　　如果用户不想执行删除操作，用户单击 CI anchor 函数创建的超链接，然后被传回 showall 方法――用户最有可能的点击来源。

　　这里是完成这个功能的代码:

复制内容到剪贴板

PHP 代码:



   1.

      /*TRYDELETE FUNCION: interrupts deletes with an 'are you sure?

   2.

      screen'*/

   3.

         function trydelete($controller, $idno, $submit = 'no')

   4.

                {

   5.

                if($state == 'yes')

   6.

                       {$this->delete($controller, $idno, 'yes');}Instant CRUD―or Putting it All Together

   7.

       

   8.

                else{

   9.

                       $result .= "<table><tr><td>Are you sure you want to

  10.

      delete this entry?</td></tr>";

  11.

                       $result .= form_open("$controller/delete");     

  12.

                       $result .= form_hidden('id', $idno);

  13.

                       $result .= "<tr><td>";

  14.

                       $result .= form_submit('submit', 'yes');

  15.

                       $result .= "</td></tr>";

  16.

                       $result .= form_close();

  17.

                       $result .= "</table>";

  18.

                       $result .=   anchor("$controller/showall",

  19.

                                   "No, don't delete");

  20.

                       $data['text'] = $result;

  21.

                       $this->display->mainpage($data);

  22.

                       }  

  23.

                 }



　　只是为了清楚起见，这里有一张如何在删除操作中传递控制行为的图表。

5.jpg (33.36 KB)

2008-3-5 18:26



　　你可以看到，这比我们先前的例子复杂的多。模型会处理所有的工作,但用户只能调用控制器,所以如果你需要后退并向用户重新显示问题,你需要再次调用控制器。

　　不过，一旦你整理出来，它运作良好，而且还具有高度的逻辑性。CI 强加这个框架给你，但长远来说，这就是一个优势。你的代码是一致的，模块化的。注意模型和视图每次被调用时的相同处:他们向用户展示什么依赖于调用他们的 CRUD 模型里的方法。





Insert 方法



　　这是最复杂的方法，因为它生成一个让用户填写的表单。（和人相关的接口总是最复杂的东西……）

　　与其写两个独立的方法，一个用来插入、一个更新，而且需要建立两次表单，我写一个方法来完成这两个工作。如果你提供了一个合法的 ID 号，就更新相应的记录；如果未提供，则插入一条新记录。

　　简便起见，我没有加入我们在 delete 方法中的测试模块。

　　以下就是我们使用本章开头定义的那个数组的地方。这个方法生成了一个表格，通过使用 CI 的表单辅助函数，基于数组中特定的表单元素（下拉，文本域等等。）。方法的核心是一个状态切换来实现如下工作。

　　这段代码使用 CI 的验证类来帮助我们检查输入的数据：记住我们在初始数组中设置了验证规则。

复制内容到剪贴板

PHP 代码:



   1.

      /*the most complex function. This creates an HTML form, based on the

   2.

      description of the fields in the form array. This is sent to our

   3.

      display model, which sets up a view and shows it to the user.

   4.

      The view then sends a POST array back to the controller. The form

   5.

      can't call this model directly, so it has to call the controller,

   6.

      which refers it back to the model.

   7.

      Note the function parameters:

   8.

      1. The controller parameter is whichever controller/ table has called

   9.

      the model - eg the 'sites' controller, or the 'domains' controller.

  10.

      The controller has the same name as the table it manipulates.

  11.

      2. The optional id parameter is the id of an individual entry in that

  12.

      table.

  13.

      3. The optional 'test' parameter is so you can set the form up to make

  14.

      usable responses to self-test functions.

  15.

      */

  16.

       

  17.

          function insert($controller='', $id=0, $test='no')

  18.

          {

  19.

                $myform = '';

  20.

                $myid = 0;Instant CRUD―or Putting it All Together

  21.

       

  22.

                $currentvalue = array();

  23.

       

  24.

       

  25.

      /*test if the table exists*/

  26.

                if(!$this->db->table_exists($controller))

  27.

                       {

  28.

       

  29.

                         $place =  __FILE__.__LINE__;

  30.

                         $outcome = "exception: $place:looking for table

  31.

      $controller: it doesn't exist'";

  32.

                        if($test =='yes')

  33.

                             {  

  34.

                              return $outcome;

  35.

                             }

  36.

                       else{

  37.

                        $this->failure($outcome, $controller);

  38.

                              }

  39.

                        }

  40.

                 else

  41.

                {

  42.

                                  if($test =='yes')

  43.

                                    {  

  44.

                                    return 'OK';

  45.

                                    }  

  46.

                }

  47.

      /*end test block*/

  48.

       

  49.

      /*next check if there is an id number. If there is, we need to get the

  50.

      values to populate the table fields*/

  51.

                if(isset($id) && $id > 0)

  52.

                      {$myid = $id;

  53.

                      $this->db->where('id', $id);

  54.

                      $query = $this->db->get($controller);

  55.

                      if ($query->num_rows() > 0)

  56.

                             {

  57.

                              $row = $query->row();

  58.

      //--------------work out the values we want!

  59.

                             foreach($row as $key =>$value)

  60.

      /*

  61.

      first of all work out what value you want to show as the existing

  62.

      value in each line of the form. In priority order these are:

  63.

      1. the last value the user entered, from the post array

  64.

      2. the value from the database

  65.

      3. nothing, if neither of these is set.

  66.

      if we got here, the id does exist and is returning values, so get the

  67.

      existing values into a value array. Or, if there is something in the

  68.

      validation array, use that instead*/

  69.

                             {

  70.

                             $_POST[$key] = $this->validation->$key;

  71.

       

  72.

                             if(isset($_POST[$key]))

  73.

                                    {$currentvalue[$key] = $_POST[$key];}

  74.

                             else

  75.

                                    {$currentvalue[$key] = $value;}

  76.

                             }

  77.

       

  78.

       

  79.

      /*test block: there was an id number, so has the program gone for an

  80.

      update? if this is not a test, of course, just do the update*/

  81.

                              if($test == 'yes')

  82.

                                    {

  83.

                                    $place =  __FILE__.__LINE__;  

  84.

                                    $outcome = "exception: $place: id of $id

  85.

      returned results from $controller table so have gone for update";

  86.

                                    return $outcome;  

  87.

                                    }

  88.

       

  89.

      /*end test block*/

  90.

                              $myform .= "<tr><td colspan='2'>Update

  91.

      existing entry number $id</td></tr>";

  92.

                             }

  93.

      /*now catch situation where this query isn't returning results. We

  94.

      could only have got here with an integer set as our ID number, so  

  95.

      this probably means we are trying to delete an entry that doesn't  

  96.

      exist.*/

  97.

                      else{

  98.

                                    $place =  __FILE__.__LINE__;  

  99.

                                    $outcome = "exception: $place: despite

 100.

      id of $id cant get any results from $controller table";

 101.

       

 102.

       

 103.

                             if($test == 'yes')

 104.

      /*test block: there was and ID but there were no results*/

 105.

                                    {

 106.

                                    return $outcome;  

 107.

                                    }

 108.

      /*end test block*/

 109.

                              else   

 110.

                                    {$this->failure($outcome, $controller);}

 111.

       

 112.

       

 113.

                              }   

 114.

                       }      

 115.

       

 116.

       

 117.

      /*there was no ID number, so this is a new entry*/

 118.

                else{

 119.

      /*If the user has filled in values, and has returned here because some

 120.

      of them didn't validate, we still need to repopulate the form with

 121.

      what he entered, so he only has to alter the one that didn't validate.

 122.

      Get these from the post array*/

 123.

       

 124.

       

 125.

                      if(isset($_POST))

 126.

                             {

 127.

                             foreach($_POST as $key => $value)Instant CRUD―or Putting it All Together

 128.

       

 129.

                                    {

 130.

                                     if(isset($_POST[$key]))

 131.

                                       {$currentvalue[$key] = $_POST[$key];}     

 132.

                                     }  

 133.

       

 134.

                             }                    

 135.

                       $myform .= "<tr><td colspan='2'>New entry</td></tr>";

 136.

       

 137.

      /*test block: there was no ID, so this is a new entry*/

 138.

                             if($test == 'yes')

 139.

                                    {

 140.

                                    $place =  __FILE__.__LINE__;  

 141.

                                    $outcome = "exception: $place: id of $id

 142.

      treated as no id, so going for new entry";

 143.

                                    return $outcome;  

 144.

                                    }

 145.

      /*end test block*/

 146.

                       }      

 147.

       

 148.

       

 149.

       

 150.

      /*the table exists, whether this is an update or new entry, so start

 151.

      to build the form*/

 152.

                $myform      .=     "<table class='table'>";

 153.

                $myform .= form_open("$controller/interim");

 154.

                $myform .= '<p>This entry could not be made because...</P>';

 155.

                $myform .= $this->validation->error_string;

 156.

       

 157.

       

 158.

       

 159.

      /*the rest of this function is common to inserts or update.

 160.

      Look up in the form array which form field type you want to display,

 161.

      and then build up the html for each different type, as well as

 162.

      inserting the values you want it to echo.*/

 163.

       

 164.

       

 165.

       

 166.

       

 167.

                       foreach($this->form[$controller] as $key => $value)

 168.

                       {

 169.

       

 170.

       

 171.

      /*This switch statement develops several types of HTML form field

 172.

      based on information in the form array.

 173.

      It doesn't yet cover checkboxes or radio or password fields. It adds

 174.

      a 'readonly' type, which is a field that only displays a value and

 175.

      doesn't let the user modify it*/     

 176.

       

 177.

       

 178.

                       $fieldtype = $value[1];

 179.

                       $val_string = $this->validation->$key;

 180.

                       switch($value[1])

 181.

                              {

 182.

      /*a simple input line*/

 183.

                             case 'input':

 184.

                             $data = array(

 185.

                       'name'        => $key,

 186.

                       'id'          => $key,

 187.

                      'value'       => $currentvalue[$key],

 188.

                      'maxlength'   => '100',

 189.

                      'size'        => '50',

 190.

                      'style'       => 'width:50%',

 191.

                  );

 192.

                             $myform .= "<tr><td>$value[0]</td><td>";

 193.

                             $myform .= form_input($data);

 194.

                             $myform .= "</td></tr>";

 195.

                             if($test == 'second')

 196.

                                    {

 197.

                                    return 'input';  

 198.

                                    }

 199.

                             break;

 200.

       

 201.

                            case 'textarea':

 202.

      /*a text area field.*/

 203.

                             $data = array(

 204.

                       'name'        => $key,

 205.

                       'id'          => $key,

 206.

                       'value'       => $currentvalue[$key],

 207.

                       'rows'       => '6',

 208.

                       'cols'        => '70',

 209.

                       'style'       => 'width:50%',

 210.

                  );                       

 211.

                             $myform .= "<tr><td valign=

 212.

                                                  'top'>$value[0]</td><td>";

 213.

                             $myform .= form_textarea($data);

 214.

                             $myform .= "</td></tr>";

 215.

                             break;

 216.

       

 217.

       

 218.

                             case 'dropdown':

 219.

      /*a drop-down box. Values are dynamically generated from whichever

 220.

      table was specified in the forms array. This table must have an id

 221.

      field (which is now entered in the form) and a name field (which is

 222.

      displayed in the drop-down box).*/

 223.

                             $dropbox = array();

 224.

                             if(isset($value[3]))

 225.

                                    {

 226.

                                    $temptable = $value[3];  

 227.

                                    $this->db->select('id, name');

 228.

                                    $query = $this->db->get($temptable);

 229.

                                    if ($query->num_rows() > 0)

 230.

                                          {

 231.

                                          foreach ($query->result() as $row)

 232.

                                           {

 233.

                                           $dropbox[$row->id] = $row->name;

 234.

                                           }

 235.

                                          }

 236.

                                   }Instant CRUD―or Putting it All Together

 237.

       

 238.

                             $myform .= "<tr><td valign=

 239.

                                                  'top'>$value[0]</td><td>";

 240.

                             $myform .= form_dropdown($key, $dropbox,

 241.

      $currentvalue[$key]);

 242.

                             $myform .= "</td></tr>";

 243.

                             break;

 244.

       

 245.

       

 246.

                             case 'submit':

 247.

      /*a submit field*/                        

 248.

                             $myform .= "<tr><td>$value[0]</td><td>";

 249.

                             $time  =  time();

 250.

                             $data = array(

 251.

                    'name'        => 'submit',

 252.

                    'id'          => 'submit',

 253.

                  );

 254.

                             $myform .= form_submit($data);

 255.

                             $myform .= "</td></tr>";

 256.

       

 257.

       

 258.

                             break;

 259.

       

 260.

       

 261.

                             case 'hidden':

 262.

      /*generates a hidden field*/

 263.

                             $myform .= form_hidden($key,

 264.

      $currentvalue[$key]);

 265.

                             break;   

 266.

       

 267.

       

 268.

                             case 'readonly':

 269.

      /*generates a field the user can see, but not alter.*/

 270.

       

 271.

                             $myform .= "<tr><td>$value[0]</td><td>$current

 272.

      value[$key]";

 273.

       

 274.

       

 275.

                             $myform .= form_hidden($key,

 276.

      $currentvalue[$key]);

 277.

                             $myform .= "</td></tr>";

 278.

       

 279.

                             break;   

 280.

       

 281.

       

 282.

                             case 'timestamp':

 283.

      /*generates a timestamp the first time it's set*/

 284.

      //                     $myform .= "<tr><td>$value[0]</td><td>now()";

 285.

                             $timenow = time();

 286.

       

 287.

       

 288.

          if($currentvalue[$key]==''||$currentvalue[$key]==0)

 289.

                                     {$time = $timenow;}

 290.

                             else{$time = $currentvalue[$key];}

 291.

       

 292.

       

 293.

                             $myform .= form_hidden($key, $time);

 294.

                             $myform .= "</td></tr>";

 295.

       

 296.

                             break;   

 297.

       

 298.

       

 299.

                             case 'updatestamp':

 300.

      /*generates a timestamp each time it's altered or viewed*/

 301.

      //                     $myform .= "<tr><td>$value[0]</td><td>now()";

 302.

       

 303.

                             $timenow = time();

 304.

                             $myform .= form_hidden($key, $timenow);

 305.

                             $myform .= "</td></tr>";

 306.

       

 307.

                             break;   

 308.

       

 309.

                             default:

 310.

                             $place =  __FILE__.__LINE__;  

 311.

                             $outcome = "exception: $place:  

 312.

                                            switch can't handle $fieldtype";

 313.

      /*test block: what if the switch doesn't recognise the form type?'*/

 314.

                              if($test == 'second')

 315.

                                    {

 316.

                                    return $outcome;  

 317.

                                   }

 318.

      /*test block ends*/

 319.

                             else {

 320.

       

 321.

                             $this->failure($outcome, $controller);  

 322.

                                    }

 323.

                             }

 324.

      /*end the foreach loop which generates the form*/

 325.

                }

 326.

                $myform .= form_hidden('submit',$time);

 327.

                $myform .= form_close();

 328.

                $myform .= "</table>";

 329.

       

 330.

       

 331.

      /*Finally we've built our form and populated it! Now, stuff the form

 332.

      in an array variable and send it to the model which builds up the rest

 333.

      of the view.*/

 334.

                $data['text'] = $myform;

 335.

                $this->display->mainpage($data);

 336.

      }



　　有很多东西需要在这里解释。所有的表单域类型都是标准的，除非是只读――就是说，一个只允许看而不允许改变的隐藏表单域。这并不安全，当然：一个聪明的用户可以轻易的获取这个值。它只是设计用来区分不同的用户。

　　你将注意到表单指向一个方法叫做 interim ，所有的控制器都需要调用它。重申一下，这是因为你无法直接通过 URL 来调用一个模型（model）。因此，如果 URL 由“site”控制器来处理，则表单的传值给 “site/interim”，数据由用户输入或者已经存在，通过 $_POST 数组被传递到哪儿。如果你在此调用本章开始部分，那个方法就会调用 crud 方法 insert2， 通过 $_POST 数组以变量形式传递。





insert2 方法



　　Insert2 接收 $_POST 数组作为参数并检测其中是否含有 “id” 域。如果有，就更新该纪录；否则就插入一条新纪录。

　　为了使用 CI 的验证类，需要 $_POST 数组，我们的方法将接收 $_POST 为参数。

复制内容到剪贴板

PHP 代码:



   1.

         function insert2($controller, $newpost, $test = 'no')

   2.

                {

   3.

                $myform = '';

   4.

       

   5.

       

   6.

      /*test the incoming parameters*/

   7.

                if(!$this->db->table_exists($controller))

   8.

                {

   9.

      //test here!

  10.

                }

  11.

       

  12.

                $this->load->library('validation');

  13.

       

  14.

       

  15.

      /*handle the validation. Note that the validation class works from

  16.

      the post array, whereas this function only has a $newpost array: same

  17.

      data, but different name. So we re-create the $_POST array.

  18.

      */

  19.

                $_POST = $newpost;

  20.

       

  21.

       

  22.

      /*now build up the validation rules from the entries in our master

  23.

      array*/

  24.

                $errorform = '';

  25.

                $newtemparray = $this->form[$controller];

  26.

                foreach($newtemparray as $key => $value)

  27.

                       {$rules[$key]= $value[2];}

  28.

                $this->validation->set_rules($rules);

  29.

       

  30.

       

  31.

      /*and the name fields*/

  32.

                foreach($newtemparray as $key => $value)

  33.

                      {$fields[$key]= $value[0];}

  34.

                $this->validation->set_fields($fields);

  35.

       

  36.

       

  37.

       

  38.

       

  39.

          $this->validation->set_fields($fields);

  40.

       

  41.

       

  42.

      /*now do the validation run*/

  43.

                if ($this->validation->run() == FALSE)

  44.

                       {

  45.

      /*if the validation run fails, re-present the entry form by calling

  46.

      the 'insert' function*/

  47.

                      $id = $_POST['id'];

  48.

                      $this->insert($controller, $id, 'no', $_POST);

  49.

       

  50.

       

  51.

                       }

  52.

                else

  53.

                {

  54.

      /*The validation check was OK so we carry on. Check if there is an id

  55.

      number*/

  56.

                if(isset($_POST['id']) && $_POST['id'] > 0)

  57.

                       {

  58.

      /*if yes: this is an update, so you don't want the id number in the

  59.

      post array because it will confuse the autoincrement id field in the

  60.

      database. Remove it, but save it in $tempid to use in the 'where'

  61.

      condition of the update query, then do the update*/

  62.

                       $tempid = $_POST['id'];

  63.

                       unset($_POST['id']);  

  64.

                       $this->db->where('id', $tempid);

  65.

                       $this->db->update($controller, $_POST);

  66.

                       if($this->db->affected_rows()== 1)

  67.

                             {$this->showall($controller, "Entry number

  68.

      $tempid updated.");}

  69.

                       else{$this->failure("Failed to update $controller for

  70.

      id no $tempid", __FILE__,__LINE__);}  

  71.

       

  72.

      /*if no id number, we assume this is a new entry: no need to unset the

  73.

      post array id as it isn't there! the database will create its own id

  74.

      number. Do the new entry*/

  75.

                       $this->db->insert($controller, $_POST);

  76.

                       if($this->db->affected_rows()== 1)

  77.

                              {$this->showall($controller,  

  78.

                                                       "New entry added.");}

  79.

                       else{$this->failure("Failed to make new entry in  

  80.

      $controller ", __FILE__,__LINE__);}   

  81.

                      }

  82.

                      }               

  83.

                  }



　　这就是全部。百余行的代码，让在任何表格上实现 CRUD 。





测试套件



　　还记得 delete 方法中的“测试模块”吗？它们的目的在于简单的测试方法是“实际”运行还是只是一个测试，然后确定返回一个容易测试的数值。

　　这是因为，在 CRUD 模型的最后，我们还有一个“自测试（self-test）”套件。它在任一控制器中（不管是哪一个）都会被调用并通过使用一个虚拟的表格实现全面的地 CRUD 测试。

　　在 CRUD 类中首先有一个控制方法 “test”，仅是用来访问其他方法。

复制内容到剪贴板

PHP 代码:



   1.

      /*now a suite of self-test functions.*/

   2.

       

   3.

       

   4.

      /*first function just calls all the others and supplies any formatting

   5.

      you want. Also it builds/ destroys temporary data table before/ after

   6.

      tests on the database.*/

   7.

          function test()

   8.

                {

   9.

                $return = "<h3>Test results</h3>";  

  10.

                $this->extendarray();

  11.

                $return .= $this->testarray();

  12.

                $this->reducearray();

  13.

                $return .= $this->testarray();

  14.

                $this->testbuild();  

  15.

                $return .= $this->testdelete();

  16.

                $this->testdestroy();

  17.

                $return .= $this->testinsert();

  18.

                $return .= $this->testinsert2();

  19.

                $return .= $this->testshowall();

  20.

                $data['text'] = $return;

  21.

                $this->display->mainpage($data);

  22.

                }



　　这里集中了所有你想要的测试，并运行这些方法。

　　然而，不用运行所有这些方法，我们只要展示一个：一个叫做 testdelete() 的方法。

　　首先，虽然，我们需要两个方法：一个用来建立，一个用来销毁我们的虚拟表格，“fred”。 第一个方法销毁所有存在的“fred”表格，建立另外一个，将一系列测试数据存入其中：

复制内容到剪贴板

PHP 代码:



   1.

      /*this function builds a new temporary table. 'fred', in your database

   2.

      so you can test the CRUD functions on it without losing real data*/

   3.

         function testbuild()

   4.

         {

   5.

           $this->db->query("DROP TABLE IF EXISTS fred");

   6.

           $this->db->query("CREATE TABLE IF NOT EXISTS fred (id INT(11)

   7.

      default NULL, name varchar(12) default NULL)");

   8.

           $this->db->query("INSERT INTO fred ALUES (1, 'bloggs')");

   9.

         }



　　如果需要，你可以设置得更复杂一些――比如，通常更多表单域，或者跟多行数据。

　　第二部分是销毁表格我们才能再次运行。那需要没有任何数据在里面，在我们删除测试之后，除非失败了或者写入了其他测试，让我们确认一下。

复制内容到剪贴板

PHP 代码:



   1.

      /*this function destroys the temporary table, to avoid any confusion

   2.

      later on*/

   3.

          function testdestroy()

   4.

          {

   5.

            $this->db->query("DROP TABLE IF EXISTS fred");

   6.

          }



现在我们开始测试 delete 方法:

复制内容到剪贴板

PHP 代码:



   1.

         function testdelete()

   2.

         {

   3.

         $result = '<p>Deletion test</p>';



　　第一个测试中我们要确认 delete 方法拦截了所有 $state 变量不为 yes 的删除动作，并将其发送给 trydelete 方法来询问“确定？”

　　记住我们希望程序正确地处理所有可能的情况并测试能返回“OK”，如果不是可能性本身的“right”与“wrong”。因此，“state”变量是 “haggis（这里只是一个right和wrong不同的字符串，不用具体考究haggis的实际意义）”，这明显是“wrong”，在程序多次对测试说“not yes”之后，测试需要说“OK”。我们只是希望一小段高亮的错误提示：如果测试成功，我们不需要了解细节。

　　首先我们建立一个数组，它所有的舰只都是测试中可能用到的表达式，他们对应的值就是我们需要的结果：

复制内容到剪贴板

PHP 代码:



   1.

          $states = array(

   2.

                             'no'  =>  'exception',

   3.

                             '1'   =>  'exception',

   4.

                             'haggis'=>  'exception',

   5.

                             'yyyes' =>  'exception',

   6.

                             'yes'  =>   'OK'

   7.

                            );

   8.

       

   9.

          foreach($states AS $testkey => $testvalue)

  10.

                 {$test = $this->delete('fred', 1, $testkey, 'yes');

  11.

      /*if you got the value you want, preg_match returns 1*/

  12.

                 $result .=  $this->unit->run(preg_match("/$testvalue/",

  13.

      $test), 1, $test);

  14.

                 }



　　假设我们的代码运行顺利，它将会返回：

6.gif (9.94 KB)

2008-3-5 18:26



　　我们下面将要进行的测试是看如何，在正确的条件下，delete 方法对一系列的 ID 值做出反应――包括非整数值、负数值等等。注意测试的颗粒性，比如大于 0 的整数 9999 就是是一个非法 ID ，在我们只有一条记录的情况下不会导致任何删除的操作。你需要明确你在测试的阶段。

复制内容到剪贴板

PHP 代码:



   1.

      /*given $state set to 'yes', test another array of values for the id

   2.

      number. Start by building a test table*/

   3.

         $this->testbuild();

   4.

      /*then another array of values to test, and the results you expect..*/

   5.

          $numbers = array(

   6.

                      '9999' =>     'OK',

   7.

                      '-1'   =>     'exception',

   8.

                      'NULL' =>     'exception',

   9.

                      '0'    =>     'exception',

  10.

                      '3.5'  =>     'exception',

  11.

                      ''     =>     'exception',

  12.

                      '1'    =>     'OK'

  13.

                      );

  14.

       

  15.

      /*now do the tests*/

  16.

          foreach($numbers AS $testkey => $testvalue)

  17.

                  {$test = $this->delete('fred', $testkey, 'yes', 'yes');

  18.

                $result       .=    $this->unit->run(preg_match("/

  19.

      $testvalue/", $test), 1, $test);

  20.

                }

  21.

      /*destroy the test table, just in case*/

  22.

          $this->testdestroy();

  23.

      /*return the results of this test*/

  24.

          return $result;

  25.

         }



　　一切顺利的话，它将返回如下：

7.gif (10 KB)

2008-3-5 18:26



　　你可以增加很多其他的你想要的测试。

　　测试有助于开发过程。在你在测试数组中放入不同值得时候，你必须考虑你的代码真的能够得体的处理他们。

　　以后它将有助于你，在你改变代码突然获得错误提示时；一旦代码放入产业环境，经常性的运行测试将让你宽心。





总结



　　本章很长，但集中描绘了很多内容。我们看到了：





    * 如何概括 CRUD 操作使你能够通过两个类完成它们：一个是控制器，还一个是 CRUD 模型。表单在各个表格中重复，但后者总是一样。

    * 我们加入各种检查和安全保护，比如测试，我们可以确认完成 CRUD 操做。





　　使用 CI，可以让我们将所有功能用几百行（相对的）简单的代码实现，我们可以多次用于几乎所有我们所架设的网站，为我们提供了一个遵守简单命名和布局的规则。对我而言，框架就是要这样。